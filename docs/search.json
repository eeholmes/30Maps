[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Eli’s 30 Maps",
    "section": "",
    "text": "https://twitter.com/tjukanov/status/1576650170535936001\nSome of these are just code from others and some I altered substantially."
  },
  {
    "objectID": "index.html#thumbnails",
    "href": "index.html#thumbnails",
    "title": "Eli’s 30 Maps",
    "section": "Thumbnails",
    "text": "Thumbnails\n\n\n\n Day 2 Lines\n\n\n Day 7 Raster – R code\n\n\n\n\n Day 8 OSM data – R code\n\n\n Day 11 Red – R code\n\n\n\n\n Day 16 Minimal – R code\n\n\n Day 18 Blue – R code\n\n\n\n\n Day 18b Blue – R code\n\n\n Day 19 Globe – R code\n\n\n\n\n Day 20 Favorite – R code\n\n\n Day 22 Movement – R code"
  },
  {
    "objectID": "content/day11.html",
    "href": "content/day11.html",
    "title": "Day 11 Red",
    "section": "",
    "text": "https://twitter.com/dhernangomez/status/1591710364571504640\nhttps://gist.github.com/dieghernan/2ea67063a08a674514bc55e74fb30bf8"
  },
  {
    "objectID": "content/day11.html#code-to-download-the-data",
    "href": "content/day11.html#code-to-download-the-data",
    "title": "Day 11 Red",
    "section": "Code to download the data",
    "text": "Code to download the data\n\n\nCode\nlibrary(tidyverse)\nlibrary(sf)\n\n# Center and circle ----\ncity_coords <- tibble(address = \"Mazama, Washington\") |> \n  tidygeocoder::geocode(address, method = 'osm', long = long, lat = lat)\nlong <- city_coords$long[1]\nlat <- city_coords$lat[1]\ncrs2 <- 6384 # https://epsg.io/6384\nmazama_center <-\n  tibble(long, lat) %>%\n  st_as_sf(coords = c(\"long\", \"lat\"), crs = 4326)\n\ncity_coords <- tibble(address = \"Winthrop, Washington\") |> \n  tidygeocoder::geocode(address, method = 'osm', long = long, lat = lat)\nlong <- city_coords$long[1]\nlat <- city_coords$lat[1]\ncrs2 <- 6384 # https://epsg.io/6384\nwinthrop_center <-\n  tibble(long, lat) %>%\n  st_as_sf(coords = c(\"long\", \"lat\"), crs = 4326)\n\n# circle to crop in ----\ndist <-  50000\ncircle <- tibble(long, lat) %>%\n  st_as_sf(coords = c(\"long\", \"lat\"), crs = 4326) %>%\n  st_transform(crs = crs2) %>%\n  st_buffer(dist = dist) %>%\n  st_transform(crs = 4326)\n\n\n\n\nCode\n# See https://dieghernan.github.io/202210_tidyterra-hillshade/\n\nlibrary(tidyterra)\nlibrary(geodata)\nlibrary(scales)\nr <- elevation_30s(country = \"USA\", path = tempdir())\nnames(r) <- \"alt\"\n\nr <- crop(r, circle)\nr <- mask(r, circle, inverse=FALSE)\n\nslope <- terrain(r, \"slope\", unit = \"radians\")\naspect <- terrain(r, \"aspect\", unit = \"radians\")\nhill <- shade(slope, aspect, 30, 270)\nhill <- mask(hill, circle, inverse=FALSE)\naspect <- mask(aspect, circle, inverse=FALSE)\nslope <- mask(slope, circle, inverse=FALSE)\n\n# normalize names\nnames(hill) <- \"shades\"\n\n# Hillshading, but we need a palette\npal_greys <- hcl.colors(1000, \"Grays\")\n\nindex <- hill %>%\n  mutate(index_col = rescale(shades, to = c(1, length(pal_greys)))) %>%\n  mutate(index_col = round(index_col)) %>%\n  pull(index_col)\n\n\n# Get cols\nvector_cols <- pal_greys[index]"
  },
  {
    "objectID": "content/day11.html#plot-code",
    "href": "content/day11.html#plot-code",
    "title": "Day 11 Red",
    "section": "Plot code",
    "text": "Plot code\nSome testing.\n\n\nCode\nlibrary(\"ggrepel\")\n\nggplot() +\n  geom_spatraster(data = slope, fill=vector_cols, maxcell = Inf) +\n  geom_sf(data=winthrop_center) + \n  geom_text_repel(data = winthrop_center, aes(x=long, y=lat), label=\"Winthrop\", \n        fontface = \"bold\", nudge_x = .1, nudge_y = 0.1)\n\n\n\n\n\n\n\nCode\nggplot() +\n  geom_spatraster(data = hill, fill=vector_cols, maxcell = Inf) +\n  geom_spatraster(data=r, maxcell = Inf) +\n  scale_fill_hypso_tint_c(limits = as.vector(minmax(r)), \n                          palette = \"dem_poster\",\n                          alpha =0.8,\n                          labels = scales::label_comma(),\n                          breaks = c(seq(0,1000, 250), seq(2000, 6000, 1000))) +\n  guides(fill=guide_legend(title = \"elevation\", reverse = TRUE)) +\n  labs(title = \"Methow Valley, WA\") +\n  geom_sf(data = circle, color = \"black\", fill =  NA, linewidth = 2) +\n  geom_sf(data=winthrop_center) + \n  geom_text_repel(data = winthrop_center, aes(x=long, y=lat), label=\"Winthrop\", \n        fontface = \"bold\", nudge_x = .1, nudge_y = 0.1) +\n  geom_sf(data=mazama_center) + \n  geom_text_repel(data = mazama_center, aes(x=st_coordinates(mazama_center)[1], y=st_coordinates(mazama_center)[2]), label=\"Mazama\", \n        fontface = \"bold\", nudge_x = .1, nudge_y = 0.1) +\n  theme_void() +\n  theme(plot.title = element_text(hjust = 0.5, size = 30))"
  },
  {
    "objectID": "content/day16.html",
    "href": "content/day16.html",
    "title": "Day 16 Minimal",
    "section": "",
    "text": "Minimal Roads from https://twitter.com/kyle_e_walker/status/1592857115928199169\nUses the {tigris} package which downloads shapefiles from the United States Census Bureau and loads them into R as ‘sf’ objects."
  },
  {
    "objectID": "content/day16.html#code-to-download-the-data",
    "href": "content/day16.html#code-to-download-the-data",
    "title": "Day 16 Minimal",
    "section": "Code to download the data",
    "text": "Code to download the data\n\nlibrary(tigris)\nlibrary(tidyverse)\nlibrary(sf)\n\nsmallwood <- places(\"WA\", cb = TRUE) %>%\n  filter(str_detect(NAME, \"Winthrop\"))\n\nsmallwood_roads <- roads(\"WA\", \"Okanogan County\") %>%\n  st_intersection(smallwood) %>%\n  filter(st_is(., \"LINESTRING\"))"
  },
  {
    "objectID": "content/day16.html#plot-code",
    "href": "content/day16.html#plot-code",
    "title": "Day 16 Minimal",
    "section": "Plot code",
    "text": "Plot code\n\nggplot(smallwood_roads) + \n  geom_sf() + \n  theme_minimal(base_size = 16) + \n  labs(title = \"Roads in Winthrop, WA\")"
  },
  {
    "objectID": "content/day18.html",
    "href": "content/day18.html",
    "title": "Day 18 blue",
    "section": "",
    "text": "https://twitter.com/leeolney3/status/1593402445283180545\nhttps://github.com/leeolney3/30DayMapChallenge/blob/main/2022/scripts/18_Blue.R"
  },
  {
    "objectID": "content/day18.html#code-to-download-the-data",
    "href": "content/day18.html#code-to-download-the-data",
    "title": "Day 18 blue",
    "section": "Code to download the data",
    "text": "Code to download the data\n\n\nCode\nlibrary(tidyverse)\nlibrary(tigris)\nlibrary(sf)\nlibrary(ggtext)\nlibrary(showtext)\nshowtext_opts(dpi = 300)\nshowtext_auto(enable = TRUE)\n\n# Fonts\nfont_add_google(\"Sora\")\nf1 = \"Sora\"\nfont_add_google(\"Open Sans\")\nf2 = \"Open Sans\"\n\n# Data\nwater_area = area_water(\"washington\", \"okanogan county\", year = 2022) \nwater_linear = linear_water(\"washington\", \"okanogan county\", year = 2022) \n\n\nSet the bounding box.\n\n\nCode\nlibrary(osmdata)\nlibrary(sf)\nlibrary(tidyverse)\n\n# Center and circle ----\ncity_coords <- tibble(address = \"Winthrop, Washington\") |> \n  tidygeocoder::geocode(address, method = 'osm', long = long, lat = lat)\n\nlong <- city_coords$long[1]\nlat <- city_coords$lat[1]\n\ncrs2 <- 6384 # https://epsg.io/6384\ncenter_proj <-\n  tibble(long, lat) %>%\n  st_as_sf(coords = c(\"long\", \"lat\"), crs = 4326)\n\n# 10km circle to crop in ----\ndist <-  10000\ncircle <- tibble(long, lat) %>%\n  st_as_sf(coords = c(\"long\", \"lat\"), crs = 4326) %>%\n  st_transform(crs = crs2) %>%\n  st_buffer(dist = dist) %>%\n  st_transform(crs = 4326)\n\nwater_area_crop <- water_area %>%\n  st_transform(crs = 4326) %>%\n  st_intersection(circle)\nwater_linear_crop <- water_linear %>%\n  st_transform(crs = 4326) %>%\n  st_intersection(circle)"
  },
  {
    "objectID": "content/day18.html#plot-code",
    "href": "content/day18.html#plot-code",
    "title": "Day 18 blue",
    "section": "Plot code",
    "text": "Plot code\n\n\nCode\nggplot() +\n  geom_sf(data = circle, color = \"black\", fill =  \"white\") +\n  geom_sf(data=water_area_crop, fill=\"#173C6D\",color=\"#173C6D\", size=.4) +\n  geom_sf(data=water_linear_crop, color=\"#0096c7\", size=.3) +\n  coord_sf() +\n  theme_void() +\n  theme(\n    plot.subtitle = element_markdown(size=13, lineheight = 1, face=\"bold\", hjust=.5, margin=margin(t=-10)),\n    plot.title = element_markdown(family=f2, size=7.5, lineheight=1.4,margin=margin(l=-70, t=300, b=-350)),\n    plot.caption=element_text(family=f2,color=\"#33415c\",hjust = .5, size=7, margin=margin(t=-5)),\n    plot.margin=margin(t=0,l=3,r=.2,b=.3,unit=\"cm\"),\n    plot.background = element_rect(fill = \"grey98\", color = NA)\n    ) +\n  labs(subtitle=\"Winthrop, Washington\", \n       title=\"<span style='font-size:12pt;color:#173C6D'><b>Area hydrography</b></span><br><span style='color:#173C6D;'>(ponds, lakes, oceans, swamps)</span><br><br><span style='font-size:12pt;color:#0096c7'><b>Linear hydrography</b></span><br><span style='color:#0096c7'>(streams/rivers, braided streams, canals,<br>ditches, artificial paths, aqueducts)</span>\", \n       caption=\"#30DayMapChallenge 18 Color Friday: Blue\\nSource: US Census via {tigris} R package\")"
  },
  {
    "objectID": "content/day18b.html",
    "href": "content/day18b.html",
    "title": "Day 18 blue (b)",
    "section": "",
    "text": "Inspired by this https://twitter.com/imagineazhar/status/1593571328484790272 but then I went in a different direction."
  },
  {
    "objectID": "content/day18b.html#code-to-download-the-data",
    "href": "content/day18b.html#code-to-download-the-data",
    "title": "Day 18 blue (b)",
    "section": "Code to download the data",
    "text": "Code to download the data\n\n\nCode\nlibrary(marmap)\nlibrary(tidyverse)\nlibrary(sf)\nlibrary(sysfonts)\nlibrary(showtext)\nlibrary(ggtext)\n\n\n\n# ------ Typography ------ \n\nfont_add_google(\"Mukta\", \"title_font\")\nshowtext_auto()\n\ntitle_font <- \"title_font\"\n\n\n# ------ Color palette ------ \n\npalette <- colorRampPalette(c(\"#03045e\", \"#0077b6\", \"#00b4d8\",\n                              \"#90e0ef\", \"#caf0f8\", \"#caf0f8\"))\n\n# --- Coord\n\ncity_coords <- tibble(address = \"Seattle, Washington\") |> \n  tidygeocoder::geocode(address, method = 'osm', long = long, lat = lat)\n\nlong <- city_coords$long[1]\nlat <- city_coords$lat[1]\n\nbathmetry <- getNOAA.bathy(lat1 = lat, lat2 = lat+4, lon1 = long, lon2 = long-3, resolution = 1)\n\ndf <- fortify.bathy(bathmetry)|>\n  filter(z < 0)\n\n\nSet the bounding box.\n\n\nCode\ncrs2 <- 6384 # https://epsg.io/6384\n\n# 10km circle to crop in ----\ndist <-  70000\ncircle <- tibble(long=long-1, lat=lat+1) %>%\n  st_as_sf(coords = c(\"long\", \"lat\"), crs = 4326) %>%\n  st_transform(crs = crs2) %>%\n  st_buffer(dist = dist) %>%\n  st_transform(crs = 4326)\n\nbathy_crop <- df %>%\n  st_as_sf(coords = c(\"x\", \"y\"), crs = 4326) %>%\n  st_transform(crs = 4326) %>%\n  st_intersection(circle)"
  },
  {
    "objectID": "content/day18b.html#plot-code",
    "href": "content/day18b.html#plot-code",
    "title": "Day 18 blue (b)",
    "section": "Plot code",
    "text": "Plot code\n\n\nCode\nggplot(df) +\n  geom_tile(aes(x = x, y = y, fill = z)) +\n  coord_sf(ylim = c(lat, lat+3), xlim = c(long, long-3), expand = FALSE) +\n  geom_sf(data = circle, color = \"black\", fill =  NA) +\n  scale_fill_gradientn(colors = palette(10),\n                       labels = function(x) format(-x, big.mark = \" \", trim = TRUE)) +\n  guides(fill = guide_colorbar(label.position = \"left\", title = \"Depth (m)\")) +\n  theme_void() +\n  theme(\n    legend.position = \"right\",\n    legend.key.height = unit(2.5, \"line\"),\n    legend.key.width = unit(0.75, \"line\"),\n    plot.background = element_rect(fill = \"#FFFBF8\", color = NA),\n    plot.title = element_markdown(size=7.5)\n    ) + \n  ggtitle(\"Circle is the region of interest\")\n\n\nCoordinate system already present. Adding new coordinate system, which will\nreplace the existing one.\n\n\n\n\n\n\n\nCode\nggplot() +\n  geom_sf(data = circle, color = \"black\", fill =  \"white\") +\ngeom_sf(data=bathy_crop, aes(color=z), size=1) +\n  ggtitle(\"Puget Sound Bathymetry\") +\nscale_color_gradientn(colors = palette(10),\n                       labels = function(x) format(-x, big.mark = \" \", trim = TRUE)) +\n  guides(color = guide_colorbar(label.position = \"left\", title = \"Depth (m)\"))"
  },
  {
    "objectID": "content/day19.html",
    "href": "content/day19.html",
    "title": "Day 19 globe",
    "section": "",
    "text": "https://twitter.com/ryanahart/status/1593966022553489410\nhttps://twitter.com/dhernangomez/status/1591710364571504640\nhttps://twitter.com/geokaramanis/status/1593999504323317760\nhttps://github.com/curatedmess/30DayMapChallenge/blob/main/2022/11192022/qatar.R\n\nBut see this globe by @geokaramanis for the Day 7 raster entry https://github.com/gkaramanis/30DayMapChallenge/tree/main/2022/07-raster-earth"
  },
  {
    "objectID": "content/day19.html#code-to-download-the-data",
    "href": "content/day19.html#code-to-download-the-data",
    "title": "Day 19 globe",
    "section": "Code to download the data",
    "text": "Code to download the data\nThe basic libraries\n\nlibrary(tidyverse)\nlibrary(sf)\n\nGet the Seattle lat/lon\n\n\nCode\n# Center\ncity_coords <- tibble(address = \"Seattle, Washington\") |> \n  tidygeocoder::geocode(address, method = 'osm', long = long, lat = lat)\nlong <- city_coords$long[1]\nlat <- city_coords$lat[1]\ncrs2 <- 6384 # https://epsg.io/6384\ncoord_center <-\n  tibble(long, lat) %>%\n  sf::st_as_sf(coords = c(\"long\", \"lat\"), crs = 4326)\n\n\nSet the projection. Had to futz a bit to get something that was close and didn’t throw an error w ggplot.\n\ncrs_string <- paste0(\"+proj=ortho +lat_0=\", lat, \" +lon_0=\", long)\n# crs_string <- \"+proj=ortho +lat_0=45 +lon_0=-105\"\n\nGet US elevations and define hill shading. This will be spatraster and comes with a projection which you can check with terra::crs(). We don’t need to change that; just need to know that it is specified.\n\n\nCode\nlibrary(tidyterra) # for geom_spatraster\nlibrary(geodata)\nlibrary(scales)\nr <- geodata::elevation_global(res=10, path = tempdir())\nnames(r) <- \"alt\"\n\nslope <- terra::terrain(r, \"slope\", unit = \"radians\")\naspect <- terra::terrain(r, \"aspect\", unit = \"radians\")\nhill <- terra::shade(slope, aspect, 30, 270)\n\n# give the hill shading a name so I can refer to it in aes()\nnames(hill) <- \"shades\"\n\n\nCreate a blue globe that will represent the ocean. 637100 is the radius of the earth in meters.\n\n\nCode\n# these are sf functions\nocean <- st_point(x = c(0,0)) %>%\n  st_buffer(dist = 6371000) %>%\n  st_sfc(crs = crs_string)"
  },
  {
    "objectID": "content/day19.html#plot-code",
    "href": "content/day19.html#plot-code",
    "title": "Day 19 globe",
    "section": "Plot code",
    "text": "Plot code\nCreate my globe. The palette “dem_poster” comes from tidyterra package.\n\n\nCode\nlibrary(ggfx) # for with_shadow\np1 <- ggplot() +\n  with_shadow(geom_sf(data = ocean, fill = \"#BBDEFB\", color = NA), sigma = 30, x_offset = 25, y_offset = 25, color = \"#58595d\") +\n  geom_spatraster(data = hill, aes(fill=shades), maxcell = Inf) +\n  geom_spatraster(data=r, maxcell = Inf) +\n  scale_fill_hypso_tint_c(limits = as.vector(minmax(r)), \n                          palette = \"dem_poster\",\n                          alpha =0.8,\n                          labels = scales::label_comma(),\n                          breaks = c(seq(0,1000, 250), seq(2000, 6000, 1000))) +\n  guides(fill=guide_legend(title = \"elevation\", reverse = TRUE)) +\n  coord_sf(crs = crs_string) +\n  theme_void()\np1\n\n\n\n\n\nThen add some annotation. The x and y units are in meters, so the nudge has to be huge (millions).\n\n\nCode\nlibrary(\"ggrepel\")\np2 <- p1 + geom_sf(data=coord_center) + \n  geom_text_repel(data = coord_center, aes(x=st_coordinates(coord_center)[1], y=st_coordinates(coord_center)[2]), label=\"Seattle\", \n        nudge_x = -3371000, nudge_y = -1371000) +\n  labs(\n    title = \"Globe with elevations\",\n    caption = \"Graphic: EE Holmes\"\n  ) +\n  theme(\n    plot.background = element_rect(fill = \"grey97\", color = NA),\n    plot.margin = unit(c(.5,.5,.5,.5), \"cm\"),\n    plot.title = element_text(hjust = 0.045, size = 26, face = \"bold\")\n  )\np2\n\n\n\n\n\nSwap out that square background with one with rounded corners. Well this didn’t really work since I couldn’t figure out how to save.\n\n\nCode\nlibrary(grid)\ng <- ggplotGrob(p2)\nbg <- g$grobs[[1]]\nround_bg <- roundrectGrob(x=bg$x, y=bg$y, width=bg$width, height=bg$height,\n                          r=unit(0.1, \"snpc\"),\n                          just=bg$just, name=bg$name, gp=bg$gp, vp=bg$vp)\ng$grobs[[1]] <- round_bg\ngrid.draw(g)\n\n\nFor some reason the shadowing looks wrong in the html. Looks like this in the saved image:\n\nknitr::include_graphics(here::here(\"content\", \"globe_elevation.png\"))"
  },
  {
    "objectID": "content/day19.html#save-image",
    "href": "content/day19.html#save-image",
    "title": "Day 19 globe",
    "section": "Save image",
    "text": "Save image\n\nggsave(paste0(\"globe_elevation\", \".png\"), dpi = 320, width = 8, height = 8)"
  },
  {
    "objectID": "content/day2.html",
    "href": "content/day2.html",
    "title": "Day 2 Lines",
    "section": "",
    "text": "https://milospopovic.net/mapping-wind-data-in-r/ using his code. I made some changes to the code but it is largely adapted and copied from Milos Popovic 2022/08/28.\nThis uses the {metR} package function geom_streamline() to plot the lines. Nice blog on using this for wind and current plot here: Plotting streamlines by Masumbuko Semba."
  },
  {
    "objectID": "content/day2.html#set-up",
    "href": "content/day2.html#set-up",
    "title": "Day 2 Lines",
    "section": "Set up",
    "text": "Set up\nInstall packages.\n\n# libraries we need\nlibs <- c(\n  \"tidyverse\", \"sf\", \"giscoR\",\n  \"lubridate\", \"classInt\",\n  \"rWind\", \"metR\", \"oce\", \"tidyterra\"\n)\n\n# install missing libraries\ninstalled_libs <- libs %in% rownames(installed.packages())\nif (any(installed_libs == F)) {\n  install.packages(libs[!installed_libs])\n}\n\n# load libraries\ninvisible(lapply(libs, library, character.only = T))\n\nSpecifications for date and location.\n\nyear <- 2022\nmonth <- c(start = 8, end = 8)\nday <- c(start = 27, end = 28)\nby <- \"1 hours\"\nlatlon <- c(xmin = -28.5, xmax = 58.5, ymin = 34.0, ymax = 73.5)\n\nGet wind function\n\nget_wind_data <- function(time_range, mean_wind_data, eur_wind_df) {\n  time_range <- seq(lubridate::ymd_hms(paste(year, month[1], day[1], 00, 00, 00, sep = \"-\")),\n    lubridate::ymd_hms(paste(year, month[2], day[2], 00, 00, 00, sep = \"-\")),\n    by = by\n  )\n\n  mean_wind_data <- rWind::wind.dl_2(time_range, latlon[1], latlon[2], latlon[3], latlon[4]) %>%\n    rWind::wind.mean()\n\n  df <- as.data.frame(mean_wind_data)\n  return(df)\n}\n\nGet wind data and make into a raster for plotting later.\n\ncrs_string <- \"+proj=longlat +datum=WGS84 +no_defs\"\nfilePath <- here::here(\"content\", \"data\", paste0(\"wind-\", year, \"-\", month[1], \"-\", day[1], \".RData\"))\nif (!file.exists(filePath)) {\n  df <- get_wind_data()\n  save(df, file = filePath)\n} else {\n  load(filePath)\n}\ncolnames(df) <- c(\"time\", \"lat\", \"lon\", \"u\", \"v\", \"dir\", \"vel\")\ndf2 <- data.frame(x = df$lon, y = df$lat, z = df$vel)\nras <- raster::rasterFromXYZ(df2, crs = crs_string)\nbb <- st_bbox(ras)\nlibrary(terra)\nr <- terra::rast(ras)\nnames(r) <- \"vel\"\nsetMinMax(r)\n\nGet the land polygons.\n\nregion <- c(\"Europe\", \"Asia\")\nland_sf <- giscoR::gisco_get_countries(\n  year = \"2016\", epsg = \"4326\",\n  resolution = \"10\", region = region\n)\n\nTest plot of the raster of wind speed.\n\nautoplot(r) +\n  geom_sf(\n    data = land_sf,\n    fill = NA,\n    color = \"#07CFF7\",\n    linewidth = 1,\n    alpha = .99\n  ) +\n  coord_sf(\n    crs = crs_string,\n    xlim = c(bb[\"xmin\"], bb[\"xmax\"]),\n    ylim = c(bb[\"ymin\"], bb[\"ymax\"]),\n    expand = FALSE\n  )\n\n\n\n\nSet up colors for lines and the legend.\n\n# colors\ncols <- c(\n  \"#feebe2\", \"#d84594\", \"#bc2b8a\", \"#7a0177\"\n)\n\nnewcol <- colorRampPalette(cols)\nncols <- 6\ncols2 <- newcol(ncols)\n\n# breaks\nvmin <- min(df$vel, na.rm = T)\nvmax <- max(df$vel, na.rm = T)\n\nbrk <- classInt::classIntervals(df$vel,\n  n = 6,\n  style = \"fisher\"\n)$brks %>%\n  head(-1) %>%\n  tail(-1) %>%\n  append(vmax)\n\nWarning in classInt::classIntervals(df$vel, n = 6, style = \"fisher\"): N is\nlarge, and some styles will run very slowly; sampling imposed\n\nbreaks <- c(vmin, brk)\n\nMake the plot. the after_stat() bit is to delay the calculation of the color until after geom_streamline() does some grouping, I think. Anyhow just using color = sqrt(vel) doesn’t work. I am not sure where the size warning is coming from since I don’t use it in any aes(). Maybe from geom_streamline()?\n\np <- df %>%\n  ggplot() +\n  geom_sf(\n    data = land_sf,\n    fill = \"grey90\",\n    color = \"#07CFF7\",\n    linewidth = .5,\n    alpha = .99\n  ) +\n  metR::geom_streamline(\n    data = df,\n    aes(\n      x = lon, y = lat, dx = u, dy = v,\n      color = sqrt(after_stat(dx)^2 + after_stat(dy)^2)\n    ),\n    L = 2, res = 2, n = 60,\n    arrow = NULL, lineend = \"round\",\n    alpha = .85\n  ) +\n  geom_sf(\n    data = land_sf,\n    fill = NA,\n    color = \"#07CFF7\",\n    linewidth = .5,\n    alpha = .5\n  ) +\n  coord_sf(\n    crs = crs_string,\n    xlim = c(bb[\"xmin\"], bb[\"xmax\"]),\n    ylim = c(bb[\"ymin\"], bb[\"ymax\"]),\n    expand = FALSE\n  ) +\n  scale_color_gradientn(\n    name = \"Average speed (m/s)\",\n    colours = cols2,\n    breaks = breaks,\n    labels = round(breaks, 1),\n    limits = c(vmin, vmax)\n  ) +\n  guides(\n    fill = \"none\",\n    color = guide_legend(\n      direction = \"horizontal\",\n      keyheight = unit(2.5, units = \"mm\"),\n      keywidth = unit(15, units = \"mm\"),\n      title.position = \"top\",\n      title.hjust = .5,\n      label.hjust = .5,\n      nrow = 1,\n      byrow = T,\n      reverse = F,\n      label.position = \"bottom\"\n    )\n  ) +\n  theme_bw() +\n  theme(legend.position = c(.5, .1))\np\n\nWarning: Using the `size` aesthetic in this geom was deprecated in ggplot2 3.4.0.\nℹ Please use `linewidth` in the `default_aes` field and elsewhere instead.\n\n\n\n\n\n\naxissize <- 30\np2 <- p +\n  theme(\n    axis.text.x = element_text(size = axissize),\n    axis.text.y = element_text(size = axissize),\n    axis.title.x = element_text(size = axissize),\n    axis.title.y = element_text(size = axissize),\n    legend.text = element_text(size = 60, color = \"black\"),\n    legend.title = element_text(size = 80, color = \"black\"),\n    legend.key = element_blank(),\n    legend.spacing.y = unit(.5, \"pt\"),\n  )\nggsave(\n  filename = \"eur_wind.png\",\n  width = 8.5, height = 7, dpi = 300, p2\n)"
  },
  {
    "objectID": "content/day20.html",
    "href": "content/day20.html",
    "title": "Day 20 favorite",
    "section": "",
    "text": "A course I took on Species Distribution modeling (sdm). I wrote up my course project into a bookdown book. This was my first foray into making maps in R. https://eeholmes.github.io/Species-Dist-Modeling—Trillium/\nLink to just the R code for map"
  },
  {
    "objectID": "content/day20.html#set-up-vermont-and-new-hampshire-boundaries",
    "href": "content/day20.html#set-up-vermont-and-new-hampshire-boundaries",
    "title": "Day 20 favorite",
    "section": "Set-up Vermont and New Hampshire boundaries",
    "text": "Set-up Vermont and New Hampshire boundaries\nThere is surely an easier way to do this.\n\nlibrary(sp)\nlibrary(raster)\nlibrary(maps)\n\nFirst I need to define an raster::extent object for a box bounding NH and VT.\n\nNHVT <- raster::extent(-73.61056, -70.60205, 42.48873, 45.37969)\n\nI download the shapefile for the NH and VT state borders using getData() which gives polygons for countries. Level 1 will be the state boundaries (I assume). The shape file has all the states. Then I use subset() to get the two states that I want. path says where to save the downloaded file.\n\nusashp <- raster::getData('GADM', country='USA', level=1, path=\"data\")\nnhvtshp <- subset(usashp, NAME_1 %in% c(\"New Hampshire\", \"Vermont\"))\n\nCheck the projection for this shapefile:\n\ncrs(nhvtshp)\n\nI can plot the shapes.\n\nplot(nhvtshp, border=\"blue\", axes=TRUE)\n\n\n\n\nI save the shapefile data to a file so I can use it later.\n\nsave(nhvtshp, NHVT, file=here::here(\"content\", \"data\", \n\"shapefiles.RData\"))"
  },
  {
    "objectID": "content/day20.html#download-trillium-records",
    "href": "content/day20.html#download-trillium-records",
    "title": "Day 20 favorite",
    "section": "Download Trillium records",
    "text": "Download Trillium records\nThis map will use the following libraries:\n\nlibrary(dismo) # as sdm package\nlibrary(sp)\nlibrary(here)\n\nLoad the shapefiles created earlier.\n\nload(file=here::here(\"content\", \"data\", \n\"shapefiles.RData\"))\n\nDownload records\nI will download occurrence data for Trillium grandiflorum and Trillium undulatum in my NHVT bounding box from the Global Biodiversity Information Facility. nrecs seems to be ignored. geo means only points with longitude and latitude. removeZeros means get rid of NA in location. ext is the bounding box to use.\nFirst I set where I will save the file and check if it is already there. I do this because if I rerun this script, I don’t want to re-download. Note that GBIF data is updated weekly so using a time-stamp on your file might be good, but I am not doing that for this example.\n\nfilePath <- here::here(\"content\", \"data\", \"trillium_presences.RData\")\n\nNow I download if I haven’t downloaded already because this takes awhile. The downloaded data has many columns that I don’t need. I will subset the following columns. select in the subset() call says what columns to use.\n\nif (!file.exists(filePath)) {\n  # Download\n  grandiflorum <- dismo::gbif(\"Trillium\",\n    species = \"grandiflorum\",\n    nrecs = 300, geo = TRUE,\n    removeZeros = TRUE, ext = NHVT\n  )\n  undulatum <- dismo::gbif(\"Trillium\",\n    species = \"undulatum\",\n    nrecs = 300, geo = TRUE,\n    removeZeros = TRUE, ext = NHVT\n  )\n  # select columns\n  colsWeNeed <- c(\"species\", \"lat\", \"lon\", \"locality\", \"year\", \"coordinateUncertaintyInMeters\", \"occurrenceID\", \"occurrenceRemarks\", \"geodeticDatum\")\n  grandiflorum <- subset(grandiflorum, select = colsWeNeed)\n  undulatum <- subset(undulatum, select = colsWeNeed)\n  trillium.raw <- rbind(grandiflorum, undulatum)\n  save(trillium.raw, file = filePath)\n}\n\nLoad in the presences data (saved from code above).\n\nload(filePath)\n\nCheck the projection to make sure it makes sense and there is only one value. Check that it is the same projection as my other layers.\n\nunique(trillium.raw$geodeticDatum) # \"WGS84\"\n\n[1] \"WGS84\"\n\n\ntrillium.raw is just a data frame. I make it a sp object (specifically a SpatialPointsDataFrame) using sp::coordinates() to specify which columns are the longitude and latitude.\n\ntrillium <- trillium.raw\nsp::coordinates(trillium) <- c(\"lon\", \"lat\")\n\nCheck that it looks ok and there are no NAs.\n\nsummary(trillium$lon)\n\n   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. \n -73.61  -73.01  -72.57  -72.38  -71.73  -70.60 \n\nsummary(trillium$lat)\n\n   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. \n  42.49   43.61   44.18   44.00   44.47   45.38 \n\n\nThe coordinateUncertaintyInMeters column give the uncertainty of the observation location. Some of the uncertainties are huge and I don’t want those.\n\ntable(cut(trillium$coordinateUncertaintyInMeters, c(0, 200, 500, 1000, 2000, 5000)))\n\n\n      (0,200]     (200,500]   (500,1e+03] (1e+03,2e+03] (2e+03,5e+03] \n         3131           142            92            87           118 \n\n\nI am going to keep only those locations with a location accuracy within 200m.\n\ngood <- which(trillium$coordinateUncertaintyInMeters < 200)\ntrillium <- trillium[good, ]"
  },
  {
    "objectID": "content/day20.html#plot-the-locations",
    "href": "content/day20.html#plot-the-locations",
    "title": "Day 20 favorite",
    "section": "Plot the locations",
    "text": "Plot the locations\nNow I can plot the occurrences points and add the NH and VT state boundaries. Trillium undulatum is much more common.\n\nplot(nhvtshp, border = \"blue\", axes = TRUE)\nplot(subset(trillium, species == \"Trillium grandiflorum\"), pch = 19, cex = 0.25, add = TRUE)\nplot(subset(trillium, species == \"Trillium undulatum\"), pch = 19, cex = 0.25, col = \"red\", add = TRUE)\ntitle(\"Trillium grandiflorum (black) and Trillium undulatum (red) records\", cex.main=0.75)"
  },
  {
    "objectID": "content/day20.html#save",
    "href": "content/day20.html#save",
    "title": "Day 20 favorite",
    "section": "Save",
    "text": "Save\n\npng(file = \"day20_trillium.png\", bg = \"white\")\nplot(nhvtshp, border = \"blue\", axes = TRUE)\nplot(subset(trillium, species == \"Trillium grandiflorum\"), pch = 19, cex = 0.25, add = TRUE)\nplot(subset(trillium, species == \"Trillium undulatum\"), pch = 19, cex = 0.25, col = \"red\", add = TRUE)\ntitle(\"Trillium grandiflorum (black) and Trillium undulatum (red) records\", cex.main=1)\ndev.off()"
  },
  {
    "objectID": "content/day21.html",
    "href": "content/day21.html",
    "title": "Day 20 favorite",
    "section": "",
    "text": "Re-create this image\nhttps://twitter.com/geokaramanis/status/1594723822871142405\nhttps://github.com/gkaramanis/30DayMapChallenge/blob/main/2022/21-kontur-1000/21-kontur-1000.R"
  },
  {
    "objectID": "content/day22.html",
    "href": "content/day22.html",
    "title": "Day 22 Movement",
    "section": "",
    "text": "Today’s goal is to recreate the ARGO float animated image from this blog post: annimate oceanographic data by Masumbuko Semba GitHub\nI ended up using more of this code: @HansenDJohnson https://hansenjohnson.org/post/bathymetric-maps-in-r/ and @geokaramanis https://github.com/gkaramanis/30DayMapChallenge/tree/main/2022/07-raster-earth\nThis will allow me to practice some new skills:\n\nARGO float data. I have never worked with that.\nLearn to process netCDF file in R. It’s been awhile since I have done that.\n{gganimate} to animate plots\nUse the {marmap} R package for oceanographic data"
  },
  {
    "objectID": "content/day22.html#set-up",
    "href": "content/day22.html#set-up",
    "title": "Day 22 Movement",
    "section": "Set-up",
    "text": "Set-up\n\nlibrary(here)\nlibrary(tidyverse)\nlibrary(stringr)\nlibrary(sf)\nlibrary(ncdf4)\n\nlibrary(marmap)\nlibrary(tidyterra)\nlibrary(ggnewscale)\nlibrary(gganimate)\nlibrary(lubridate)"
  },
  {
    "objectID": "content/day22.html#download-the-argo-data",
    "href": "content/day22.html#download-the-argo-data",
    "title": "Day 22 Movement",
    "section": "Download the ARGO data",
    "text": "Download the ARGO data\nI went here and downloaded an ARGO float netCDF for a float in the Black Sea. https://dataselection.euro-argo.eu/\n\nncfile <- here::here(\"content\", \"data\", \"GL_PR_PF_6903766.nc\")\nargo <- ncdf4::nc_open(ncfile)\n\nFigure out the names of things. Sadly this isn’t a proper ARGO file so oce:read.argo() doesn’t work.\n\nnames(argo$var)\n\n [1] \"TIME_QC\"                  \"POSITION_QC\"             \n [3] \"DC_REFERENCE\"             \"DIRECTION\"               \n [5] \"VERTICAL_SAMPLING_SCHEME\" \"PRES\"                    \n [7] \"PRES_QC\"                  \"TEMP\"                    \n [9] \"TEMP_QC\"                  \"PSAL\"                    \n[11] \"PSAL_QC\"                 \n\nnames(argo$dim)\n\n[1] \"TIME\"      \"DEPTH\"     \"LATITUDE\"  \"LONGITUDE\" \"POSITION\"  \"STRING32\" \n[7] \"STRING256\"\n\n\nA bit of poking reveals that the ARGO float data is from 2 sampling schemes: one at the surface and the other that is sampling as the flow goes down. I’ll use just the data from the “Primary sampling” at the surface.\n\na <- ncdf4::ncvar_get(argo, \"VERTICAL_SAMPLING_SCHEME\")\ngood <- stringr::str_detect(a, \"Primary sampling\")\na[1:3]\n\n[1] \"Primary sampling: averaged [10 sec sampling 1 dbar average from surface to 100 dbar; 10 sec sampling 2 dbar average from 100 dbar to 500 dbar; 10 sec sampling 5 dbar average from 500 dbar to 1000 dbar]\" \n[2] \"Primary sampling: averaged [10 sec sampling 5 dbar average from 2000 dbar to 500 dbar; 10 sec sampling 2 dbar average from 500 dbar to 100 dbar; 10 sec sampling 1 dbar average from 100 dbar to 2.4 dbar]\"\n[3] \"Near-surface sampling: averaged unpumped [10 sec sampling 1 dbar average from 2.4 dbar to surface]\"                                                                                                        \n\n\nNext I notice that the time is in julian days so I will need to convert that. There are a few ways to convert julian to date/time. Making the origin date a POSIXlt date object and adding on the seconds is an easy way.\n\n# print(argo) and you'll see the ref time\nto <- as.POSIXlt(\"1950-01-01\")\n\n\nargo_df <- tibble(\n  time = ncvar_get(argo, \"TIME\"),\n  lon = ncvar_get(argo, \"LONGITUDE\"),\n  lat = ncvar_get(argo, \"LATITUDE\"),\n  temp = ncvar_get(argo, \"TEMP\")[1,],\n  psal = ncvar_get(argo, \"PSAL\")[1,]\n) %>% subset(good) %>%\n  mutate(date = to+time*60*60*24) %>% # need to convert time to secs\n  mutate(qtr = as.character(quarter(date)))"
  },
  {
    "objectID": "content/day22.html#black-sea",
    "href": "content/day22.html#black-sea",
    "title": "Day 22 Movement",
    "section": "Black Sea",
    "text": "Black Sea\nUsing https://www.latlong.net/, I grabbed box coordinates.\n\ny <- c(39, 47)\nx <- c(26, 44)"
  },
  {
    "objectID": "content/day22.html#make-the-bathymetry-plot",
    "href": "content/day22.html#make-the-bathymetry-plot",
    "title": "Day 22 Movement",
    "section": "Make the bathymetry plot",
    "text": "Make the bathymetry plot\nGet bathymetry.\n\nbathy <- marmap::getNOAA.bathy(x[1], x[2], y[1], y[2], resolution = 3)\n\nQuerying NOAA database ...\n\n\nThis may take seconds to minutes, depending on grid size\n\n\nBuilding bathy matrix ...\n\nbathy_df <- marmap::fortify.bathy(bathy)\n\n\nautoplot.bathy(bathy, geom=c(\"tile\",\"contour\")) +\n    scale_fill_gradient2(low=\"dodgerblue4\", mid=\"gainsboro\", high=\"darkgreen\")\n\n\n\n\nMap a map with the ARGO data added.\n\nbasemap <- ggplot() +\n  # water raster\n  geom_raster(data = bathy_df %>% filter(z < 0), aes(x, y, fill = z), show.legend=FALSE) +\n  scale_fill_hypso_c(\"etopo1_bathy\") +\n  # add contours\n  geom_contour(data = bathy_df %>% filter(z < 0), \n               aes(x=x, y=y, z=z),\n               breaks=c(-100),\n               linewidth=c(0.3),\n               colour=\"grey\") +\n  geom_contour(data = bathy_df %>% filter(z < 0), \n               aes(x=x, y=y, z=z),\n               breaks=c(-500, -1000, -1500, -2000),\n               linewidth=c(0.3),\n               colour=\"white\") +\n  new_scale_fill() +\n  # Add argo points\n  geom_point(data = argo_df, aes(x = lon, y = lat, color = temp), size=3) +\n  scale_colour_steps2(low = \"blue\", mid = \"white\", high = \"red\",\n    midpoint = mean(argo_df$temp), name=\"temperature (C)\") +\n  new_scale_fill() +\n  # land raster\n  geom_raster(data = bathy_df %>% filter(z >= 0), aes(x, y, fill = z), show.legend=FALSE) +\n  scale_fill_hypso_c(\"gmt_globe_hypso\") +\n  theme_void() +\n  theme(\n    legend.position = \"bottom\"\n  ) + \n  ggtitle(\"An Argo bouy in the Black Sea\")\nbasemap\n\n\n\n\n\n## map the location\nargo.animate <- basemap +\n geom_label(\n    data = argo_df %>% slice(seq(1,dim(argo_df)[1],14)),\n    aes(label = format(date, \"%b %Y\")), x=35, y=43)+\n  transition_time(date)+\n  ease_aes(\"sine-in-out\")+\n  shadow_mark()\n\ngganimate::animate(argo.animate)"
  },
  {
    "objectID": "content/day22.html#save",
    "href": "content/day22.html#save",
    "title": "Day 22 Movement",
    "section": "Save",
    "text": "Save\n\ngganimate::anim_save(here::here(\"content\", \"argo.gif\"))"
  },
  {
    "objectID": "content/day7.html",
    "href": "content/day7.html",
    "title": "Day 7 Raster",
    "section": "",
    "text": "require(devtools)\ndevtools::install_github(\"ropensci/rerddap\")\ndevtools::install_github(\"rmendels/rerddapXtracto\") \n\n\nlibrary(tidyverse)\n\n── Attaching packages ─────────────────────────────────────── tidyverse 1.3.2 ──\n✔ ggplot2 3.4.0      ✔ purrr   0.3.5 \n✔ tibble  3.1.8      ✔ dplyr   1.0.10\n✔ tidyr   1.2.1      ✔ stringr 1.4.1 \n✔ readr   2.1.3      ✔ forcats 0.5.2 \n── Conflicts ────────────────────────────────────────── tidyverse_conflicts() ──\n✖ dplyr::filter() masks stats::filter()\n✖ dplyr::lag()    masks stats::lag()\n\nlibrary(tidyterra)\n\n\nAttaching package: 'tidyterra'\n\nThe following object is masked from 'package:stats':\n\n    filter"
  },
  {
    "objectID": "content/day7.html#download-sea-surface-temperature-data",
    "href": "content/day7.html#download-sea-surface-temperature-data",
    "title": "Day 7 Raster",
    "section": "Download sea surface temperature data",
    "text": "Download sea surface temperature data\nI will download the optimal interpolation sea surface temperature from CoastWatch. The bounding box is off the coast of Washington, USA.\n\nfilePath <- here::here(\"content\", \"data\", \"day7_sst_raster.RData\")\nlats <- c(40.375, 50.375)\nlons <- c(-141.875, -120.875)\nif (!file.exists(filePath)) {\ndf_info <- rerddap::info(\"ncdcOisst21Agg_LonPM180\")\ndf <- rerddap::griddap(\"ncdcOisst21Agg_LonPM180\", latitude = lats, longitude = lons, time = c(\"2021-06-19\", \"2021-06-19\"), fields = \"sst\")$data\nsave(df, file=filePath)\n}else{\n  load(filePath)\n}\n\nTurn this into a raster. Need to tell raster that this is lat/long data.\n\ndf2 <- data.frame(x=df$lon, y=df$lat, z=df$sst)\nras <- raster::rasterFromXYZ(df2, crs = \"+proj=longlat\")\n\n\nlibrary(terra)\n\nterra 1.6.17\n\n\n\nAttaching package: 'terra'\n\n\nThe following object is masked from 'package:tidyr':\n\n    extract\n\nr <- terra::rast(ras)\nnames(r) <- \"alt\"\nsetMinMax(r)\nslope <- terra::terrain(r, \"slope\", unit = \"radians\")\naspect <- terra::terrain(r, \"aspect\", unit = \"radians\")\nhill <- terra::shade(slope, aspect, 10, 200)\nnames(hill) <- \"shades\"\n\n\nlibrary(scales)\n\n\nAttaching package: 'scales'\n\n\nThe following object is masked from 'package:terra':\n\n    rescale\n\n\nThe following object is masked from 'package:purrr':\n\n    discard\n\n\nThe following object is masked from 'package:readr':\n\n    col_factor\n\n# Hillshading, but we need a palette\npal_greys <- hcl.colors(1000, \"Grays\")\n\nindex <- hill %>%\n  mutate(index_col = rescale(shades, to = c(1, length(pal_greys)))) %>%\n  mutate(index_col = round(index_col)) %>%\n  pull(index_col)\n# Get cols\nvector_cols <- pal_greys[index]\n\nhill_plot <- ggplot() +\n  geom_spatraster(\n    data = hill, fill = vector_cols, maxcell = Inf,\n    alpha = 1\n  )\nhill_plot\n\n\n\n\n\nr_limits <- minmax(r) %>% as.vector()\n# Rounded to lower and upper 500\n#r_limits <- c(floor(r_limits[1] / 500), ceiling(r_limits[2] / 500)) * 500\n\nbase_plot <- hill_plot +\n  geom_spatraster(data = r, maxcell = Inf) +\n  scale_fill_hypso_tint_c(\n    limits = r_limits,\n    palette = \"dem_poster\",\n    alpha = 0.4,\n    labels = label_comma(),\n    # For the legend I use custom breaks\n    breaks = seq(-300, 1000, 100)\n  )\nbase_plot\n\n\n\n\n\nlibrary(tidyterra)\nhill_plot +\n  geom_spatraster(data=r, maxcell = Inf) +\n  scale_fill_hypso_tint_c(limits = as.vector(minmax(r)), \n                          palette = \"etopo1\",\n                          alpha =0.4,\n                          direction = 1,\n                          labels = scales::label_comma()) +\n  guides(fill=guide_legend(title = \"elevation\", reverse = FALSE))\n\n\n\n\n\nggplot() + \n  geom_spatraster(data=slope, maxcell = Inf) +\n  scale_fill_whitebox_c(palette = \"muted\", alpha = 0.9, direction = 1)\n\n\n\n  geom_spatraster(data=r, maxcell = Inf) +\n  scale_fill_whitebox_c(palette = \"muted\", alpha = 0.9, direction = 1)\n\nNULL\n\n\n\nlibrary(colorspace)\n\n\nAttaching package: 'colorspace'\n\n\nThe following object is masked from 'package:terra':\n\n    RGB\n\nhill_plot +\n  geom_spatraster(data=r, maxcell = Inf) +\n  scale_fill_continuous_diverging(\n    palette = \"Blue-Red-2\", p2 = .1, alpha=.8, mid=mean(df$sst, na.rm = TRUE))"
  },
  {
    "objectID": "content/day7.html#plot-the-raster",
    "href": "content/day7.html#plot-the-raster",
    "title": "Day 7 Raster",
    "section": "Plot the raster",
    "text": "Plot the raster\n\nlibrary(raster)\n\nLoading required package: sp\n\n\n\nAttaching package: 'raster'\n\n\nThe following object is masked from 'package:tidyterra':\n\n    select\n\n\nThe following object is masked from 'package:dplyr':\n\n    select\n\nlibrary(ggplot2)\ngg <- ggplot(df) +\n  geom_raster(aes(longitude, latitude, fill = sst)) +\n  scale_fill_gradient2(midpoint = mean(df$sst, na.rm = TRUE),\n                       low = \"blue\",\n                       mid = \"white\",\n                       high = \"red\") +\n  labs(x = NULL,\n       y = NULL,\n       fill = \"Celcius\",\n       title = \"Sea Surface Temperature (SST)\") +\n  theme_bw() +\n  scale_x_continuous(limits = lons, expand = c(-0.01, -0.01)) +\n  scale_y_continuous(limits = lats, expand = c(-0.01, -0.01))\ngg\n\nWarning: Removed 248 rows containing missing values (`geom_raster()`)."
  },
  {
    "objectID": "content/day7.html#add-a-coastline",
    "href": "content/day7.html#add-a-coastline",
    "title": "Day 7 Raster",
    "section": "Add a coastline",
    "text": "Add a coastline\n\ncoast <- rnaturalearth::ne_coastline(scale = 50, returnclass = \"sp\")\nwa_or_coast <- raster::crop(coast, raster::extent(lons[1], lons[2], lats[1], lats[2]))\nplot(wa_or_coast)\n\n\n\n\nThe way that ggplot2 works is to run fortify() on the SpatialLines object to create a data frame. Then we use geom_path() to plot that. But if you look at the coast, you see lots of islands. We need to add grouping to tell geom_path() that there are these groups of paths in the data frame.\n\ngg +\n  geom_path(data=wa_or_coast,  aes(x=long,y=lat, grouping=id), size=1, na.rm=TRUE)\n\nWarning: Using `size` aesthetic for lines was deprecated in ggplot2 3.4.0.\nℹ Please use `linewidth` instead.\n\n\nWarning in geom_path(data = wa_or_coast, aes(x = long, y = lat, grouping =\nid), : Ignoring unknown aesthetics: grouping\n\n\nWarning: Removed 248 rows containing missing values (`geom_raster()`)."
  },
  {
    "objectID": "content/day8.html",
    "href": "content/day8.html",
    "title": "Day 8 osm data",
    "section": "",
    "text": "Code from https://github.com/AbdoulMa/30DayMapChallenge/tree/main/Day8"
  },
  {
    "objectID": "content/day8.html#code-to-download-the-data",
    "href": "content/day8.html#code-to-download-the-data",
    "title": "Day 8 osm data",
    "section": "Code to download the data",
    "text": "Code to download the data\n\n\nCode\nlibrary(osmdata)\nlibrary(sf)\nlibrary(tidyverse)\n\nbbx <- getbb(paste0(\"Winthrop\", \",\", \"Washington\"))\n# Get motorway, trunk, primary, secondary, tertiary ways ----\nhighways <- bbx %>%\n  opq() %>%\n  add_osm_feature(\n    key = \"highway\",\n    value = c(\n      \"motorway\",\n      \"trunk\",\n      \"primary\",\n      \"secondary\",\n      \"tertiary\",\n      \"motorway_link\",\n      \"trunk_link\",\n      \"primary_link\",\n      \"secondary_link\",\n      \"tertiary_link\"\n    )\n  ) %>%\n  osmdata_sf()\n\n# Get small streets, pedestrian paths, living streets ----\nstreets <- bbx %>%\n  opq() %>%\n  add_osm_feature(\n    key = \"highway\",\n    value = c(\n      \"residential\",\n      \"living_street\",\n      \"service\",\n      \"unclassified\",\n      \"pedestrian\",\n      \"footway\",\n      \"track\",\n      \"path\"\n    )\n  ) %>%\n  osmdata_sf()\n\n# Get landuse ---- \nlanduse <- opq(bbx) |> \n  add_osm_feature(key = \"landuse\") |> \n  osmdata_sf() |> \n  unname_osmdata_sf()\n\n# Get buildings ---- \nbuildings <- opq(bbx) |> \n  add_osm_feature(key = \"building\") %>%\n  osmdata_sf() |> \n  unname_osmdata_sf()\n\n# Center and circle ----\ncity_coords <- tibble(address = \"Winthrop, Washington\") |> \n  tidygeocoder::geocode(address, method = 'osm', long = long, lat = lat)\n\nlong <- city_coords$long[1]\nlat <- city_coords$lat[1]\n\ncrs2 <- 6384 # https://epsg.io/6384\ncenter_proj <-\n  tibble(long, lat) %>%\n  st_as_sf(coords = c(\"long\", \"lat\"), crs = 4326)\n\n# circle to crop in ----\ndist <-  3500\ncircle <- tibble(long, lat) %>%\n  st_as_sf(coords = c(\"long\", \"lat\"), crs = 4326) %>%\n  st_transform(crs = crs2) %>%\n  st_buffer(dist = dist) %>%\n  st_transform(crs = 4326)\n\nstreets_lines <- st_intersection(circle, streets$osm_lines)\nhighways_lines <- st_intersection(circle, highways$osm_lines)\nbuildings_polygons <- st_intersection(circle, buildings$osm_polygons)\nlanduse_polygons <- st_intersection(circle, landuse$osm_polygons)"
  },
  {
    "objectID": "content/day8.html#plot-code",
    "href": "content/day8.html#plot-code",
    "title": "Day 8 osm data",
    "section": "Plot code",
    "text": "Plot code\n\n\nCode\nggplot() +\n  geom_sf(data = circle, color = \"black\", fill =  \"white\") +\n  geom_sf(\n    data = landuse_polygons,\n    fill = \"#646464\", \n    size = .05,\n    alpha = .95\n  ) + \n  geom_sf(\n    data = buildings_polygons, \n    size = .05,\n    fill = \"#c8c8c8\", \n    color = \"#c8c8c8\", \n    alpha = .75\n  ) + \n  geom_sf(\n    data = streets_lines,\n    col = \"grey40\",\n    size = .4,\n    alpha = .65\n  ) +\n  geom_sf(\n    data = highways_lines,\n    col = \"grey25\",\n    size = .6,\n    alpha = .8\n  ) +\n  ggtitle(\"Winthrop\") +\n  theme_void() + \n  theme(\n    plot.title = element_text(hjust = 0.5),\n    plot.background = element_rect(fill = \"grey98\", color = NA),\n    plot.margin = margin(b = 10)\n    )"
  }
]